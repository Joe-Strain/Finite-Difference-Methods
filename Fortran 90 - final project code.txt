PROGRAM ftcs

! *** Program: First time central space finite difference method to
! ***  approximate  a PDE,  in  this   case  the  heat   diffusion equation

USE fin_diff

IMPLICIT NONE

REAL, PARAMETER :: inuu=40, dt=0.002, alpha=0.000217, ymin=0, ymax=0.04
REAL :: dy, tt, yr
INTEGER, PARAMETER :: ny=41, nt=540, save_iter=1
INTEGER :: n
REAL, DIMENSION(ny) :: yy, uu
CHARACTER  (LEN=*), PARAMETER :: fname=”data/ftcs.dat”

! *** Set up values needed
tt=0 
yr=ymax−ymin

! *** Create yy and give it values
DO n=1, ny
yy(n)=yr*( n−1)
END DO
yy=yy / ( ny−1)+ymin dy=yy ( 2 )−yy ( 1 )
! *** Intial Conditions 
uu(1)=inuu
uu(2:ny)=0

! *** Perform FTCS and save to ’fname’
OPEN(UNIT=1,FILE=fname,FORM=”UNFORMATTED”,STATUS=”REPLACE”,ACTION=”WRITE”)

WRITE(UNIT=1) uu, tt

DO n=1, nt

CALL timestep(uu,dt,alpha,dy,ny) 

tt=tt+dt

IF (MOD(n,save_iter)==0) THEN
WRITE(UNIT=1) uu, tt
END IF

END DO CLOSE(UNIT=1)


END PROGRAM ftcs

PROGRAM dufort

! *** Program: DuFort−Frankel method to
! *** approximate a PDE, in this case the heat diffusion equation

USE fin_diff

IMPLICIT NONE

REAL, PARAMETER :: inuu=40, dt=0.002, alpha=0.000217, ymin=0, ymax=0.04
REAL :: dy, tt, yr
INTEGER, PARAMETER :: ny=41, nt=540, save_iter=1
INTEGER :: n
REAL, DIMENSION(ny) :: yy, uu, tempuu, temp2uu
CHARACTER (LEN=*), PARAMETER :: fname=”data/dufort.dat”

! *** Set up values needed
tt = 0 
yr = ymax − ymin
! *** Create array yy and give it appropriate values
DO n=1, ny
yy(n) = yr * (n − 1)
END DO
yy = yy / (ny − 1) + ymin 
dy = yy(2) − yy(1)

! *** Initial conditions 
uu(1) = inuu 
uu(2:ny) = 0

! *** Perform one step of the FTCS method and save results to ’fname’
OPEN(UNIT=1 ,FILE=fname ,FORM=”UNFORMATTED” ,STATUS=”REPLACE”, ACTION=”WRITE” )

WRITE(UNIT=1) uu,tt

! *** Temporary array to hold values of uu one time−step behin
tempuu = uu

CALL timestep(uu, dt, alpha, dy, ny)
tt = tt + dt
IF (MOD(1, saveiter) == 0) THEN
WRITE(UNIT = 1) uu, tt
END IF

! *** Perform the DuFort−Frankel method and save results to ’fname’
DO  n=1, nt−1	! *** nt−1  steps as one step of FTCS already completed
temp2uu = uu
CALL dftimestep(uu, dt, alpha, dy, ny, tempuu)

tempuu = temp2uu
tt = tt+dt

IF (MOD(n+1, saveiter) == 0) THEN
WRITE(UNIT = 1) uu, tt
END IF 
END DO

CLOSE(UNIT = 1)


END PROGRAM dufort

PROGRAM laas

! *** Program: Laasonnen implicit method to
! *** approximate a parabolic PDE
USE fin_diff

IMPLICIT NONE

REAL, PARAMETER :: inuu = 40, dt = 0.002, alpha = 0.000217, ymin = 0, ymax = 0.04
REAL :: dy, tt, yr, k
INTEGER, PARAMETER :: ny = 41, nt = 540, saveiter = 1
INTEGER :: n
REAL, DIMENSION(ny) :: yy, uu
CHARACTER(LEN=*), PARAMETER :: fname=”data/laas.dat”




! *** Setup values needed
tt = 0
yr = ymax − ymin
! *** Create yy array and calculate the diffusion number ’k’
DO n = 1, ny
yy(n) = yr * (n−1)
END DO
yy = yy / (ny−1) + ymin
dy = yy(2) − yy(1) 
k = (alpha * dt) / dy**2
! *** Initial conditions 
uu(1) = inuu
uu(2:ny) = 0

! *** Perform Laasonen method and save results to ’fname’
OPEN(UNIT = 1, FILE = fname, FORM = ”UNFORMATTED”, STATUS = ”REPLACE”, ACTION = ”WRITE”)

WRITE(UNIT = 1) uu, tt

DO  n = 1, nt
CALL laastimestep(uu, ny, inuu, k) 
tt = tt + dt
IF (MOD(1, saveiter) == 0) THEN
WRITE(UNIT=1) uu, tt
END IF
END DO
CLOSE(UNIT=1)


END PROGRAM laas

PROGRAM crank

! *** Program: Crank−Nicolsen implicit method to
! *** approximate a parabolic PDE

USE fin_diff

IMPLICIT NONE

REAL, PARAMETER :: inuu=40, dt=0.002, alpha=0.000217, ymin=0, ymax=0.04
REAL :: dy, tt, yr, k
INTEGER, PARAMETER :: ny=41, nt=540, save_iter=1
INTEGER :: n
REAL, DIMENSION(ny) :: yy, uu
CHARACTER(LEN=*), PARAMETER :: fname = ”data/crank.dat”




! *** Set up intial values
tt = 0
yr = ymax − ymin
! *** Create array yy and also calulate ’k’−diffusion number
DO n=1, ny
yy(n) = yr * (n−1)
END DO
yy = yy / (ny−1) + ymin
dy = yy(2) − yy(1)
k = (alpha * dt) / dy**2
! *** Set up initial conditions
uu(1) = inuu 
uu(2:ny) = 0

! *** Perform Crank−Nicolsen and save results to ’fname’
OPEN(UNIT=1, FILE=fname, FORM=”UNFORMATTED”, STATUS=”REPLACE”, ACTION=”WRITE”)

WRITE(UNIT=1) uu, tt

DO  n=1, nt
CALL cranktimestep(uu, ny, inuu, k) 
tt=t t+dt
IF (MOD(n, save_iter) == 0) THEN WRITE(UNIT=1) uu, tt
END IF
END DO
CLOSE(UNIT=1)


END PROGRAM crank

MODULE fin_diff
! *** Module containing subroutines and functions required to run finite
! *** difference methods to approximate PDEs

IMPLICIT NONE 

CONTAINS

! *********************************************************************************


SUBROUTINE timestep(uu, dt, alpha, dy, ny)




! *** Sub routine to calculate the solution to the PDE
! *** as we step along in time
REAL, DIMENSION(:), INTENT(INOUT) :: uu
REAL, INTENT(IN) :: dt, dy, alpha
INTEGER, INTENT(IN) :: ny

REAL, DIMENSION(SIZE(uu)) :: du

CALL pde(alpha, uu, du, dy, ny)

! *** Timestep the internal points of the spatial grid
uu(2:ny−1) = uu(2:ny−1) + dt * du(2:ny−1)
END SUBROUTINE timestep

! ********************************************************************************


SUBROUTINE pde(alpha, uu, du, dy, ny)

! *** Subroutine to calculate the right−hand side of out original PDE

REAL, DIMENSION(:), INTENT(IN) :: uu 
REAL, DIMENSION(:), INTENT(OUT) :: du
REAL, INTENT(IN) :: alpha, dy
INTEGER, INTENT(IN) :: ny

du = alpha * der2(uu, dy, ny)

END SUBROUTINE pde

! ******************************************************************


FUNCTION der2(uu, dy, ny)
! ***  This calculates the  2nd order central difference of the second
! *** derivative of our function
REAL, DIMENSION(:), INTENT(IN) :: uu
REAL, INTENT(IN) :: dy
INTEGER, INTENT(IN) :: ny

REAL, DIMENSION(SIZE(uu)) :: der2

der2(2:ny−1) = (uu(3:ny) − 2 * uu(2:ny−1) + uu(1:ny−2)) / dy**2
END FUNCTION der2




! ******************************************************************


SUBROUTINE dftimestep(uu, dt, alpha, dy, ny, tempuu)
! *** Updates the uu values by one time step using the DuFort−Frankel method

REAL, DIMENSION(:) , INTENT(INOUT) :: uu
REAL, DIMENSION(:), INTENT(IN) :: tempuu
REAL, INTENT(IN) :: dt, alpha, dy
INTEGER, INTENT(IN) :: ny

REAL :: cc

cc = (2 * alpha * dt) / dy**2
uu(2:ny−1) = ((1 − cc) * tempuu(2:ny−1) + cc * (uu(3:ny) + uu(1:ny−2))) / (1 + cc)

END SUBROUTINE dftimestep

!*****************************************************************

SUBROUTINE laastimestep(uu, ny, inuu, k)
! *** Updates the uu values by one timestep using the Laasonen implicit method

REAL, DIMENSION(:), INTENT(INOUT) :: uu
REAL, INTENT(IN) :: inuu, k
INTEGER, INTENT(IN) :: ny

REAL, DIMENSION(SIZE(uu)) :: dd
REAL :: a, b, c

! *** Set up our values for the Thompson Algorithm
dd(1:ny) = −uu(1:ny)
b = −(2 * k + 1)
a = k 
c = k

CALL thompson(uu, a, b, c, dd, inuu, ny)

END SUBROUTINE laastimestep

!**********************************************************************


SUBROUTINE cranktimestep(uu ,ny ,inuu ,k )
! *** Updates the uu values by one timestep using the Crank−Nicolsen implicit
! *** method




REAL, DIMENSION(:), INTENT(INOUT) :: uu
REAL, INTENT(IN) :: inuu, k
INTEGER, INTENT(IN) :: ny

REAL, DIMENSION(SIZE(uu)) :: dd
REAL :: a, b, c

! *** Set up our values for the Thompson Algorithm
dd(2:ny−1) = (k/2) * (uu(3:ny) − 2 * uu(2:ny−1) + uu(1:ny−2)) + uu(2:ny−1)
dd(ny) = 0

a = −k / 2 
b = 1 + k
c = −k / 2
CALL thompson (uu, a, b, c, dd, inuu, ny)

END SUBROUTINE cranktimestep

! *********************************************************************


SUBROUTINE thompson(uu, a, b, c, dd, inuu, ny)
! *** A subroutine to carry out the Thompson Algorithm for tridiagonal matrices

REAL, DIMENSION(:), INTENT(INOUT) :: uu 
REAL, DIMENSION(:), INTENT(IN) :: dd
REAL, INTENT(IN) ::  a, b, c, inuu 
INTEGER, INTENT(IN) :: ny

INTEGER :: i
REAL, DIMENSION(ny) :: hh, gg

hh(1) = 0
gg(1) = inuu

hh(2:ny) = c / (b − a * hh(1:ny−1))
gg(2:ny) = (dd(2:ny) − a * gg(1:ny−1)) / (b − a * hh(1:ny−1))
DO i=1, ny−2
uu(ny−i) = −hh(ny−i) * uu(ny−i+1) + gg(ny−i)
END DO

END SUBROUTINE thompson

!***********************************************************


END MODULE fin_diff




Pro pplate, uu, t, yy=yy, nterms=nterms, plot=plot, ny=ny, u0=u0, nu=nu, ly=ly
; Code to produce the analytical series solution to the parallel
; plate problem.  du/dt=nu*d2u/dy2
If NOT keyword_set(u0) Then u0=40.0
If NOT keyword_set(nu) Then nu=0.000217
If NOT keyword_set(nterms) Then nterms=10

If NOT keyword_set(yy) Then Begin
If NOT keyword_set(ny) Then ny=41
If NOT keyword_set(ly) Then ly=0.04 
yy=(findgen(ny)/(ny−1))*ly
Endif Else Begin 
ny=n_elements(yy)
ly=yy[ny−1]−yy[0]
Endelse

theta1=ly/(2*SQRT(nu*t))
uu=fltarr(ny)
uu[0]=u0
uu[ny−1]=0.0
nn=fltarr(ny)

For j=1,ny−2 DO Begin
nn[j]=yy[j]/(2*SQRT(nu*t))
sum=0
For k=1,nterms DO Begin
sum=sum+erfc(2*k*theta1+nn[j])−erfc(2*k*theta1−nn[j])
Endfor
uu[j]=u0*(erfc(nn[j])+sum)
Endfor

If keyword_set(plot) Then	plot, yy, uu

print, ”Terms taken= ”, nterms

End